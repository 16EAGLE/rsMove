% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modelApply.R
\name{modelApply}
\alias{modelApply}
\title{modelApply}
\usage{
modelApply(model, img)
}
\arguments{
\item{model}{List object as provided by \emph{moveModel()}.}

\item{img}{Object of class \emph{RasterLayer}, \emph{RasterStack} or \emph{RasterBrick}.}
}
\value{
A \emph{Raster}.
}
\description{
Apply a model or an ensemble of models to raster data.
}
\details{
{The function uses the output of \emph{moveModel()}. If this contains a 
list of models from multiple runs, the function creates a stack of predictions 
and summarizes it on a pixel-by-pixel basis using a weighted mean. The weights 
are defined by the average performance for \emph{presence} and \emph{background} 
samples in each iteration.}
}
\examples{
\dontrun{

 # read example data
 moveData <- shapefile(system.file('extdata', 'konstanz_20130805-20130811.shp', package="rsMove"))

 # extract samples
 ot = strptime(moveData$timestamp, "\%Y-\%m-\%d \%H:\%M:\%S")
 output <- sampleMove(xy=moveData, ot=ot, error=10, method='m')
 
 # read remote sensing data
 rsStack <- stack(list.files(system.file('extdata', '', package="rsMove"), 'tc.*tif', full.names=T))
 
 # retrieve remote sensing data for samples
 rsQuery <- dataQuery(xy=samples,img=rsStack, rd=T)
 
 # identify unique sample regions
 label <- abelSample(xy=rsQuery, rad=90, npx=4, pxr=30)
 
 # derive model predictions
 out <- moveModel(samples=c(samples@coords,label), features=rsQuery@data, nruns=5)
 
 # derive prediction from model ensemble
 applyModel(out, rsStack)
 
}
}
\seealso{
\code{\link{segRaster}} \code{\link{moveModel}}
}
